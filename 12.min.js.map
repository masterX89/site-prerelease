{"version":3,"file":"12.min.js","sources":["webpack:///./node_modules/@arco-design/web-react/es/Carousel/arrow.js","webpack:///./node_modules/@arco-design/web-react/es/Carousel/index.js","webpack:///./node_modules/@arco-design/web-react/es/Carousel/indicator.js","webpack:///./node_modules/@arco-design/web-react/es/_util/hooks/useInterval.js"],"sourcesContent":["import React, { useContext } from 'react';\nimport IconLeft from '../../icon/react-icon/IconLeft';\nimport IconRight from '../../icon/react-icon/IconRight';\nimport IconUp from '../../icon/react-icon/IconUp';\nimport IconDown from '../../icon/react-icon/IconDown';\nimport cs from '../_util/classNames';\nimport { ConfigContext } from '../ConfigProvider';\nfunction CarouselArrow(props, ref) {\n    var _a;\n    var className = props.className, direction = props.direction, showArrow = props.showArrow, prev = props.prev, next = props.next, icons = props.icons;\n    var getPrefixCls = useContext(ConfigContext).getPrefixCls;\n    var prefixCls = getPrefixCls('carousel');\n    var arrowClass = cs(prefixCls + \"-arrow\", (_a = {},\n        _a[prefixCls + \"-arrow-hover\"] = showArrow === 'hover',\n        _a), className);\n    var iconPrev = icons && icons.hasOwnProperty('prev') ? (icons.prev) : direction === 'horizontal' ? (React.createElement(IconLeft, null)) : (React.createElement(IconUp, null));\n    var iconNext = icons && icons.hasOwnProperty('next') ? (icons.next) : direction === 'horizontal' ? (React.createElement(IconRight, null)) : (React.createElement(IconDown, null));\n    return (React.createElement(\"div\", { ref: ref, className: arrowClass },\n        React.createElement(\"div\", { className: prefixCls + \"-arrow-\" + (direction === 'vertical' ? 'top' : 'left'), onClick: prev }, iconPrev),\n        React.createElement(\"div\", { className: prefixCls + \"-arrow-\" + (direction === 'vertical' ? 'bottom' : 'right'), onClick: next }, iconNext)));\n}\nvar CarouselArrowComponent = React.forwardRef(CarouselArrow);\nCarouselArrowComponent.defaultProps = {\n    direction: 'horizontal',\n    showArrow: 'always',\n};\nexport default CarouselArrowComponent;\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport React, { useContext, useEffect, useImperativeHandle, useRef, useState, } from 'react';\nimport cs from '../_util/classNames';\nimport CarouselIndicator from './indicator';\nimport CarouselArrow from './arrow';\nimport { ConfigContext } from '../ConfigProvider';\nimport { useInterval } from '../_util/hooks/useInterval';\nimport ResizeObserver from '../_util/resizeObserver';\nimport warning from '../_util/warning';\nimport omit from '../_util/omit';\nimport useMergeProps from '../_util/hooks/useMergeProps';\nvar DEFAULT_AUTO_PLAY_INTERVAL = 3000;\nvar defaultProps = {\n    animation: 'slide',\n    indicatorType: 'dot',\n    indicatorPosition: 'bottom',\n    direction: 'horizontal',\n    showArrow: 'always',\n    trigger: 'click',\n    moveSpeed: 500,\n    timingFunc: 'cubic-bezier(0.34, 0.69, 0.1, 1)',\n};\nfunction Carousel(baseProps, ref) {\n    var _a;\n    var _b = useContext(ConfigContext), getPrefixCls = _b.getPrefixCls, componentConfig = _b.componentConfig;\n    var props = useMergeProps(baseProps, defaultProps, componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.Carousel);\n    var style = props.style, className = props.className, children = props.children, currentIndex = props.currentIndex, animation = props.animation, trigger = props.trigger, direction = props.direction, moveSpeed = props.moveSpeed, timingFunc = props.timingFunc, indicatorType = props.indicatorType, indicatorPosition = props.indicatorPosition, indicatorClassName = props.indicatorClassName, showArrow = props.showArrow, miniRender = props.miniRender, arrowClassName = props.arrowClassName, carousel = props.carousel, icons = props.icons, onChange = props.onChange, rest = __rest(props, [\"style\", \"className\", \"children\", \"currentIndex\", \"animation\", \"trigger\", \"direction\", \"moveSpeed\", \"timingFunc\", \"indicatorType\", \"indicatorPosition\", \"indicatorClassName\", \"showArrow\", \"miniRender\", \"arrowClassName\", \"carousel\", \"icons\", \"onChange\"]);\n    // TODO 兼容 autoPlaySpeed， 3.x 移除\n    var autoPlay = props.autoPlay;\n    if (autoPlay && props.autoPlaySpeed) {\n        autoPlay = {\n            interval: props.autoPlaySpeed,\n        };\n        warning(true, \"[Arco Carousel] The 'autoPlaySpeed' property will be removed in the next major version, please use 'autoPlay.interval' instead.\");\n    }\n    var childrenList = React.Children.toArray(children).filter(function (child) {\n        return React.isValidElement(child);\n    });\n    var childrenLength = childrenList.length;\n    var refDom = useRef(null);\n    var refSliderWrapper = useRef(null);\n    var refAnimationTimer = useRef(null);\n    var _c = __read(useState(0), 2), index = _c[0], setIndex = _c[1];\n    var _d = __read(useState(null), 2), previousIndex = _d[0], setPreviousIndex = _d[1];\n    var _e = __read(useState(false), 2), isPause = _e[0], setIsPause = _e[1];\n    var _f = __read(useState(false), 2), isAnimating = _f[0], setIsAnimating = _f[1];\n    var _g = __read(useState(null), 2), slideDirection = _g[0], setSlideDirection = _g[1];\n    var _h = __read(useState({\n        sliderWrapper: null,\n        indicatorWrapper: null,\n    }), 2), computedStyle = _h[0], setComputedStyle = _h[1];\n    var mergedIndex = typeof currentIndex === 'number' ? getValidIndex(currentIndex) : index;\n    var prevIndex = getValidIndex(mergedIndex - 1);\n    var nextIndex = getValidIndex(mergedIndex + 1);\n    var autoPlayInterval = typeof autoPlay === 'object' && autoPlay.interval\n        ? autoPlay.interval\n        : DEFAULT_AUTO_PLAY_INTERVAL;\n    useEffect(function () {\n        return function () { return refAnimationTimer.current && clearTimeout(refAnimationTimer.current); };\n    }, []);\n    useEffect(function () {\n        slideTo({\n            targetIndex: mergedIndex,\n        });\n    }, [mergedIndex]);\n    var resetInterval = useInterval(function () {\n        slideTo({\n            targetIndex: nextIndex,\n        });\n    }, autoPlay && !isPause && childrenLength > 1 ? autoPlayInterval : null);\n    useImperativeHandle(carousel, function () {\n        return {\n            dom: refDom.current,\n            goto: function (_a) {\n                var index = _a.index, isNegative = _a.isNegative, isManual = _a.isManual, resetAutoPlayInterval = _a.resetAutoPlayInterval;\n                slideTo({\n                    targetIndex: getValidIndex(index),\n                    isNegative: isNegative,\n                    isManual: isManual,\n                    resetAutoPlayInterval: resetAutoPlayInterval,\n                });\n            },\n        };\n    });\n    function getValidIndex(i) {\n        var indexNumber = +i;\n        return typeof indexNumber === 'number' && !isNaN(indexNumber)\n            ? (indexNumber + childrenLength) % childrenLength\n            : i;\n    }\n    function slideTo(_a) {\n        var targetIndex = _a.targetIndex, _b = _a.isNegative, isNegative = _b === void 0 ? false : _b, _c = _a.isManual, isManual = _c === void 0 ? false : _c, _d = _a.resetAutoPlayInterval, resetAutoPlayInterval = _d === void 0 ? false : _d;\n        if (!isAnimating && targetIndex !== mergedIndex) {\n            setIsAnimating(true);\n            setIndex(targetIndex);\n            setPreviousIndex(index);\n            setSlideDirection(isNegative ? 'negative' : 'positive');\n            onChange && onChange(targetIndex, mergedIndex, isManual);\n            if (autoPlay && resetAutoPlayInterval) {\n                resetInterval();\n            }\n            refAnimationTimer.current = setTimeout(function () {\n                setIsAnimating(false);\n                refAnimationTimer.current = null;\n            }, moveSpeed);\n        }\n    }\n    function computeStyle() {\n        if (animation === 'card') {\n            if (refSliderWrapper.current) {\n                var sliderElement = refSliderWrapper.current.children[0];\n                if (!sliderElement) {\n                    return;\n                }\n                var totalWidth = refSliderWrapper.current.clientWidth;\n                var sliderWidth = sliderElement.clientWidth;\n                var edge = (totalWidth - sliderWidth) / 2;\n                // deltaZ is TranslateZ(-Zpx) of prev/next slider's style\n                // perspective / (perspective + deltaZ) = x / X\n                var deltaZ = 200;\n                var x = totalWidth / 2;\n                var X = sliderWidth;\n                // avoid getting a huge perspective value\n                var perspective = x + 50 >= X ? deltaZ * 4 : (deltaZ * x) / (X - x);\n                setComputedStyle({\n                    sliderWrapper: {\n                        perspective: perspective,\n                    },\n                    indicatorWrapper: {\n                        width: 'auto',\n                        left: edge,\n                        right: edge,\n                    },\n                });\n            }\n        }\n        else {\n            setComputedStyle({\n                sliderWrapper: null,\n                indicatorWrapper: null,\n            });\n        }\n    }\n    var prefixCls = getPrefixCls('carousel');\n    var classNames = cs(prefixCls, prefixCls + \"-indicator-position-\" + indicatorPosition, className);\n    var eventHandlers = Object.assign({}, autoPlay && (typeof autoPlay !== 'object' || autoPlay.hoverToPause !== false)\n        ? {\n            onMouseEnter: function () { return setIsPause(true); },\n            onMouseLeave: function () { return setIsPause(false); },\n        }\n        : null);\n    return (React.createElement(ResizeObserver, { onResize: computeStyle },\n        React.createElement(\"div\", __assign({ ref: function (_ref) {\n                ref = _ref;\n                refDom.current = ref;\n            }, className: classNames, style: style }, omit(rest, ['autoplay', 'autoPlaySpeed']), eventHandlers),\n            React.createElement(\"div\", { ref: refSliderWrapper, style: computedStyle.sliderWrapper, className: cs(prefixCls + \"-\" + animation, prefixCls + \"-\" + direction, (_a = {},\n                    _a[prefixCls + \"-negative\"] = slideDirection === 'negative',\n                    _a)) }, childrenList.map(function (child, index) {\n                var _a;\n                var isCurrent = index === mergedIndex;\n                var isPrev = index === prevIndex;\n                var isNext = index === nextIndex;\n                var shouldRenderChild = !miniRender || isCurrent || isPrev || isNext;\n                if (!shouldRenderChild) {\n                    return null;\n                }\n                var _b = child.props, childStyle = _b.style, childClassName = _b.className, childOnClick = _b.onClick;\n                return React.cloneElement(child, {\n                    style: Object.assign({\n                        transitionTimingFunction: timingFunc,\n                        transitionDuration: moveSpeed + \"ms\",\n                        animationTimingFunction: timingFunc,\n                        animationDuration: moveSpeed + \"ms\",\n                    }, childStyle),\n                    className: cs(childClassName, (_a = {},\n                        _a[prefixCls + \"-item-prev\"] = isPrev,\n                        _a[prefixCls + \"-item-next\"] = isNext,\n                        _a[prefixCls + \"-item-current\"] = isCurrent,\n                        _a[prefixCls + \"-item-slide-in\"] = animation === 'slide' && slideDirection && isAnimating && isCurrent,\n                        _a[prefixCls + \"-item-slide-out\"] = animation === 'slide' && slideDirection && isAnimating && index === previousIndex,\n                        _a)),\n                    onClick: function (event) {\n                        childOnClick && childOnClick(event);\n                        slideTo({\n                            targetIndex: index,\n                            isNegative: index === prevIndex,\n                            isManual: true,\n                        });\n                    },\n                });\n            })),\n            indicatorType !== 'never' && childrenLength > 1 && (React.createElement(\"div\", { style: computedStyle.indicatorWrapper, className: cs(prefixCls + \"-indicator-wrapper\", prefixCls + \"-indicator-wrapper-\" + indicatorPosition) },\n                React.createElement(CarouselIndicator, { className: indicatorClassName, type: indicatorType, count: childrenLength, activeIndex: mergedIndex, position: indicatorPosition, trigger: trigger, onSelectIndex: function (index) {\n                        return slideTo({\n                            targetIndex: index,\n                            isNegative: index < mergedIndex,\n                            isManual: true,\n                        });\n                    } }))),\n            showArrow !== 'never' && childrenLength > 1 && (React.createElement(CarouselArrow, { className: arrowClassName, direction: direction, showArrow: showArrow, icons: icons, prev: function () {\n                    return slideTo({\n                        targetIndex: prevIndex,\n                        isNegative: true,\n                        isManual: true,\n                    });\n                }, next: function () {\n                    return slideTo({\n                        targetIndex: nextIndex,\n                        isManual: true,\n                    });\n                } })))));\n}\nvar CarouselComponent = React.forwardRef(Carousel);\nCarouselComponent.displayName = 'Carousel';\nexport default CarouselComponent;\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport React, { useContext } from 'react';\nimport cs from '../_util/classNames';\nimport { ConfigContext } from '../ConfigProvider';\nfunction CarouselIndicator(props, ref) {\n    var _a, _b;\n    var getPrefixCls = useContext(ConfigContext).getPrefixCls;\n    var className = props.className, _c = props.type, type = _c === void 0 ? 'line' : _c, _d = props.count, count = _d === void 0 ? 2 : _d, _e = props.activeIndex, activeIndex = _e === void 0 ? 0 : _e, _f = props.position, position = _f === void 0 ? 'bottom' : _f, _g = props.trigger, trigger = _g === void 0 ? 'click' : _g, onSelectIndex = props.onSelectIndex;\n    var prefixCls = getPrefixCls('carousel-indicator');\n    var indicatorContent = [];\n    if (type === 'slider') {\n        var step = 100 / count;\n        indicatorContent.push(React.createElement(\"span\", { key: 0, style: { width: step + \"%\", left: activeIndex * step + \"%\" }, className: cs(prefixCls + \"-item\", prefixCls + \"-item-active\") }));\n    }\n    else {\n        for (var i = 0; i < count; i++) {\n            indicatorContent.push(React.createElement(\"span\", { key: i, \"data-index\": i, className: cs(prefixCls + \"-item\", (_a = {},\n                    _a[prefixCls + \"-item-active\"] = i === activeIndex,\n                    _a)) }));\n        }\n    }\n    var wrapperProps = (_b = {\n            ref: ref,\n            className: cs(prefixCls, prefixCls + \"-\" + type, prefixCls + \"-\" + position, className)\n        },\n        _b[trigger === 'click' ? 'onClick' : 'onMouseEnter'] = function (event) {\n            event.preventDefault();\n            if (type === 'slider') {\n                var x = event.nativeEvent.offsetX;\n                var width = event.currentTarget.clientWidth;\n                // clear up effect from event bubbling\n                if (event.target === event.currentTarget) {\n                    var index = ~~((x / width) * count);\n                    index !== activeIndex && onSelectIndex(index);\n                }\n            }\n            else {\n                var index = +event.target.getAttribute('data-index');\n                !isNaN(index) && index !== activeIndex && onSelectIndex(index);\n            }\n        },\n        _b);\n    return React.createElement(\"div\", __assign({}, wrapperProps), indicatorContent);\n}\nvar CarouselIndicatorComponent = React.forwardRef(CarouselIndicator);\nexport default CarouselIndicatorComponent;\n","import { useRef, useEffect } from 'react';\nexport function useInterval(callback, delay) {\n    var refIntervalId = useRef(null);\n    var refSavedCallback = useRef();\n    var setUpInterval = function () {\n        if (delay !== null) {\n            refIntervalId.current = setInterval(function () {\n                refSavedCallback.current();\n            }, delay);\n        }\n    };\n    var cleanUpInterval = function () {\n        refIntervalId.current && clearInterval(refIntervalId.current);\n    };\n    var resetInterval = function () {\n        cleanUpInterval();\n        setUpInterval();\n    };\n    // Remember the latest function.\n    useEffect(function () {\n        refSavedCallback.current = callback;\n    }, [callback]);\n    // Set up the interval.\n    useEffect(function () {\n        setUpInterval();\n        return cleanUpInterval;\n    }, [delay]);\n    return resetInterval;\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}